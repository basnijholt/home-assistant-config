import{e0 as e,l as t,ez as i,eA as a,eN as n,ey as s,eH as r,eD as o,eL as c,d$ as l,eI as u,eh as h,dX as _,eF as g,eJ as d,eG as p,e2 as m,eM as y}from"./card-4818d30e.js";import{B as f,i as C}from"./engine-browse-media-d948b15f.js";import{C as w}from"./engine-86b0096c.js";import{E as k}from"./entity-camera-8c929fa4.js";import{g as b}from"./engine-generic-b10fce62.js";import{e as D}from"./endOfDay-80d77989.js";const M=t=>e(t,(e=>e._metadata?.startDate),"desc");class E extends s{}class z extends k{constructor(){super(...arguments),this._reolinkHostID=null,this._reolinkCameraUID=null,this._reolinkChannel=null,this._ptzEntities=null}async initialize(e){return await super.initialize(e),await this._initializeChannel(e.hass,e.deviceRegistryManager),await this._initializeCapabilities(e.hass,e.entityRegistryManager,e.stateWatcher),this}async _getChannelFromConfigurationURL(e,t){const i=this._entity?.device_id;if(!i)return null;const a=await t.getDevice(e,i);if(!a?.configuration_url)return null;try{const e=new URL(a.configuration_url),t=Number(e.searchParams.get("ch"));return isNaN(t)?null:t}catch{return null}}async _initializeChannel(e,i){const a=this._entity?.unique_id,n=a?String(a).match(/^(?<hostid>[^_]+)_(?<channel_or_uid>[^_]+)_/):null,s=n?.groups?.hostid??null,r=n?.groups?.channel_or_uid??null;if(null===s||null===r)throw new E(t("error.camera_initialization_reolink"),this.getConfig());const o=Number(r),c=!isNaN(o)&&o<=999,l=(c?o:null)??await this._getChannelFromConfigurationURL(e,i)??0,u=c?null:r;this._reolinkChannel=l,this._reolinkHostID=s,this._reolinkCameraUID=u}async _initializeCapabilities(e,t,a){const n=this.getConfig(),s=b(this.getConfig());this._ptzEntities=await this._getPTZEntities(e,t);const r=this._ptzEntities?this._entitiesToCapabilities(e,this._ptzEntities):null,o=s||r?{...r,...s}:null;this._capabilities=new i({"favorite-events":!1,"favorite-recordings":!1,"remote-control-entity":!0,clips:!0,live:!0,menu:!0,recordings:!1,seek:!1,snapshots:!1,substream:!0,trigger:!0,...o&&{ptz:o}},{disable:n.capabilities?.disable,disableExcept:n.capabilities?.disable_except}),this._subscribeBasedOnCapabilities(a)}_entitiesToCapabilities(e,t){const i={};for(const e of Object.keys(t))switch(e){case"left":case"right":case"up":case"down":i[e]=[a.Continuous];break;case"zoom_in":i.zoomIn=[a.Continuous];break;case"zoom_out":i.zoomOut=[a.Continuous]}const n=t?.presets?e.states[t.presets]:null;
/* istanbul ignore next: this path cannot be reached as ptzEntities will
        always have contents when this function is called  -- @preserve */
return Array.isArray(n?.attributes.options)&&(i.presets=n.attributes.options),Object.keys(i).length?i:null}async _getPTZEntities(e,t){
/* istanbul ignore next: this path cannot be reached as an exception is
           thrown in initialize() if this value is not found -- @preserve */
if(!this._reolinkHostID)return null;const i=this._getPTZEntityUniqueIDPrefix(),a=await t.getMatchingEntities(e,(e=>e.config_entry_id===this._entity?.config_entry_id&&!!e.unique_id&&String(e.unique_id).startsWith(i)&&!e.disabled_by)),n=a.filter((e=>e.entity_id.startsWith("button."))),s=a.filter((e=>e.unique_id===`${i}ptz_preset`&&e.entity_id.startsWith("select."))),r=["stop","left","right","up","down","zoom_in","zoom_out"],o={};for(const e of n)for(const t of r)e.unique_id&&String(e.unique_id).endsWith(t)&&(o[t]=e.entity_id);return 1===s.length&&(o.presets=s[0].entity_id),Object.keys(o).length?o:null}getChannel(){return this._reolinkChannel}_getPTZEntityUniqueIDPrefix(){return`${this._reolinkHostID}_${this._reolinkCameraUID??this._reolinkChannel}_`}getProxyConfig(){return{...super.getProxyConfig(),media:"auto"===this._config.proxy.media||this._config.proxy.media,ssl_verification:"auto"!==this._config.proxy.ssl_verification&&this._config.proxy.ssl_verification,ssl_ciphers:"auto"===this._config.proxy.ssl_ciphers?"intermediate":this._config.proxy.ssl_ciphers}}async executePTZAction(e,t,i){if(await super.executePTZAction(e,t,i))return!0;if(!this._ptzEntities)return!1;if("preset"===t){const t=this._ptzEntities.presets,a=i?.preset;return!(!a||!t)&&(await e.executeActions({actions:[n("select",t,a)]}),!0)}const a="start"===i?.phase?this._ptzEntities[t]:"stop"===i?.phase?this._ptzEntities.stop:null;return!!a&&(await e.executeActions({actions:[{action:"perform-action",perform_action:"button.press",target:{entity_id:a}}]}),!0)}}class x{static isReolinkEventQueryResults(e){return e.engine===o.Reolink&&e.type===p.Event}}class v extends f{constructor(e,t,i,a,n,s,o){super(e,i,a,n,s,o),this._camerasCache=new r,this._cache=new r,this._deviceRegistryManager=t}getEngineType(){return o.Reolink}_reolinkFileMetadataGenerator(e,t,i){
/* istanbul ignore next: This situation cannot happen as the directory would
        be rejected by _reolinkDirectoryMetadataGenerator if there was no start date
        -- @preserve */
if(!i?._metadata?.startDate||t.media_class!==c)return null;const a=t.title.split(/ +/),n=l(a[0],"HH:mm:ss",i._metadata.startDate);if(!u(n))return null;const s=a.length>1?a[1].match(/(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)/):null,r=s?.groups?{hours:Number(s.groups.hours),minutes:Number(s.groups.minutes),seconds:Number(s.groups.seconds)}:null,o=a.length>2?a.splice(2).map((e=>e.toLowerCase())).sort():null;return{cameraID:e,startDate:n,endDate:r?h(n,r):n,...o&&{what:o}}}_reolinkDirectoryMetadataGenerator(e,t){const i=l(t.title,"yyyy/M/d",new Date);return u(i)?{cameraID:e,startDate:_(i),endDate:D(i)}:null}_reolinkCameraMetadataGenerator(e){const t=e.media_content_id.match(/^media-source:\/\/reolink\/CAM\|(?<configEntryID>.+)\|(?<channel>\d+)$/);return t?.groups?{configEntryID:t.groups.configEntryID,channel:Number(t.groups.channel)}:null}async createCamera(e,t){const i=new z(t,this,{eventCallback:this._eventCallback});return await i.initialize({entityRegistryManager:this._entityRegistryManager,deviceRegistryManager:this._deviceRegistryManager,hass:e,stateWatcher:this._stateWatcher})}async _getMatchingDirectories(e,t,i,a){const n=t.getConfig(),s=t.getEntity(),r=s?.config_entry_id;if(null===t.getChannel()||!r)return null;const o=await this._browseMediaWalker.walk(e,[{targets:["media-source://reolink"],metadataGenerator:(e,t)=>this._reolinkCameraMetadataGenerator(e),matcher:e=>e._metadata?.channel===t.getChannel()&&e._metadata?.configEntryID===r}],{...!1!==a?.useCache&&{cache:this._camerasCache}});return o?.length?await this._browseMediaWalker.walk(e,[{targets:[`media-source://reolink/RES|${r}|${t.getChannel()}|`+("low"===n.reolink?.media_resolution?"sub":"main")],metadataGenerator:(e,i)=>this._reolinkDirectoryMetadataGenerator(t.getID(),e),matcher:e=>e.can_expand&&C(e,i?.start,i?.end),sorter:e=>M(e)}],{...!1!==a?.useCache&&{cache:this._cache}}):null}async getEvents(t,i,a,n){if(a.favorite||a.tags?.size||a.what?.size||a.where?.size||a.hasSnapshot)return null;const s=new Map,r=async r=>{const c={...a,cameraIDs:new Set([r])},l=n?.useCache??1?this._requestCache.get(c):null;if(l)return void s.set(c,l);const u=i.getCamera(r),h=u&&u instanceof z?await this._getMatchingDirectories(t,u,c,n):null,_=c.limit??w;let g=[];h?.length&&(g=await this._browseMediaWalker.walk(t,[{targets:h,concurrency:1,metadataGenerator:(e,t)=>this._reolinkFileMetadataGenerator(r,e,t),earlyExit:e=>e.length>=_,matcher:e=>!e.can_expand&&C(e,c.start,c.end),sorter:e=>M(e)}],{...!1!==n?.useCache&&{cache:this._cache}}));const d=e(g,(e=>e._metadata?.startDate),"desc").slice(0,_),m={type:p.Event,engine:o.Reolink,browseMedia:d};(n?.useCache??1)&&this._requestCache.set(c,{...m,cached:!0},m.expiry),s.set(c,m)};return await g(a.cameraIDs,(e=>r(e))),s}generateMediaFromEvents(e,t,i,a){return x.isReolinkEventQueryResults(a)?d(a.browseMedia):null}async getMediaMetadata(e,t,i,a){const n=new Map,s=a?.useCache??1?this._requestCache.get(i):null;if(s)return n.set(i,s),n;const r=new Set,c=async i=>{const n=t.getCamera(i);if(!(n&&n instanceof z))return;const s=await this._getMatchingDirectories(e,n,null,a);for(const e of s??[])
/* istanbul ignore next: This situation cannot happen as the directory
                will not match without metadata -- @preserve */
e._metadata?.startDate&&r.add(m(e._metadata.startDate))};await g(i.cameraIDs,(e=>c(e)));const l={type:p.MediaMetadata,engine:o.Reolink,metadata:{...r.size&&{days:r}},expiry:h(new Date,{seconds:y}),cached:!1};return(a?.useCache??1)&&this._requestCache.set(i,{...l,cached:!0},l.expiry),n.set(i,l),n}getCameraMetadata(e,t){return{...super.getCameraMetadata(e,t),engineIcon:"reolink"}}getCameraEndpoints(e,t){const i=e.reolink?.url?{endpoint:e.reolink.url}:null;return{...super.getCameraEndpoints(e,t),...i&&{ui:i}}}}export{v as ReolinkCameraManagerEngine,x as ReolinkQueryResultsClassifier};
